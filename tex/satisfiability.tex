\chapter{Propositional Satisfiability\label{chap:satisfiability}}

% Signposting
In this chapter, an overview of propositional satisfiability (SAT) is provided.
We start by defining the SAT decision problem.
\Cref{sec:inc-sat} gives an overview of incremental SAT solving, a technique that the algorithmic approch proposed in this thesis makes heavy use of.
Next, we briefly discuss maximum satisfiability, the optimization variant of propositional satisfiability.
The chapter concludes with a section on encoding cardinality constraints in propositional logic.

\section{Propositional Satisfiability\label{sec:sat}}

% Propositional logic and SAT
For a Boolean variable $v$ there are two literals, the positive $v$ and the negative $\lnot v$. 
A clause $C$ is a set of (disjunction over) literals and a CNF formula $\formula$ is a set of (conjunction over) clauses.
The set of variables and literals appearing in $\formula$ are $\var(\formula)$ and $\lit(\formula)$, respectively.  
A truth assignment $\sol$ maps Boolean variables to 1 (true) or 0 (false).
The semantics of truth assignments are extended to a clause $C$ and a formula $\formula$ in the standard way: $\sol(C) = \max\{ \sol(l) \mid l \in C\}$ and $\sol(\formula) = \min\{\sol(C) \mid C \in \formula\}$.
When convenient, we view assignments $\sol$ over a set $\var(\formula)$ of variables as sets of literals $\sol = \{ v \mid v \in \var(\formula),  \sol(v) = 1\} \cup \{ \lnot v \mid v \in \var(\formula), \sol(v) = 0\}$.
An assignment $\sol$ for which $\sol(\formula) = 1$ is a solution to $\formula$.
The propositional satisfiability (SAT) problem asks whether a given formula $\formula$ has a solution.
A formula $\formula$ is satisfiable if it has solutions, otherwise it is unsatisfiable.

% Example: SAT
\begin{example}
  Consider the propositional formula $\formula_1 = a \land \lnot b$ over variables $\var(\formula_1) = \{a,b\}$.
  This formula is satisfiable since for $\sol=\{a,\lnot b\}$, $\sol(\formula_1)=1$.
  The formula $\formula_2 = a \land b \land (\lnot a \lor \lnot b)$ on the other hand is not satisfiable.
\end{example}

% SAT solvers
A SAT solver is an algorithm that determines the satisfiability of a given formula $\formula$.
If the formula is satisfiable, the solver returns ``satisfiable'' (\sat{}) and a solution $\sol$ with $\sol(\formula)=1$;
if $\formula$ is unsatisfiable, the return value is ``unsatisfiable'' (\unsat{}).

% SAT as a declarative modelling language
The SAT problem was proved to be \NP-complete by~\textcite{DBLP:conf/stoc/Cook71}.
This result is central to the modern day use of SAT as a declarative programming approach to solving other \NP-complete problems by encoding them as a propositional formula first, solving them with a SAT solver and then decoding the solution to the original problem context.
The advantage of using SAT as a declarative programming language for solving other problems comes from the fact that conflict-driven clause learning (CDCL) solvers for SAT are efficient in practice and can solve real-world instances with up to millions of variables and clauses~\autocite{handbook2-cdcl}.

% Example: SAT modelling
\begin{example}\label{ex:sat-modelling}
  \TODO{Try to come up with an example for a \emph{problem} rather than an \emph{instance}.}
  We give an example of a real-world problem, modelling and solving it with the help of SAT.
  Assume you have the following situation:
  you want to plan a meal for a guest coming over, and you do not know whether to include an appetizer, a main course and a dessert.
  However, you know the following constraints:
  (i)~there must be a main course in every meal, (ii)~having three courses is too much effort, (iii)~your guest would like to have dessert, and (iv)~you have a new appetizer recipe that you would like to try making.
  To model this situation as SAT, you can introduce three variables $v_\text{a}$, $v_\text{m}$, $v_\text{d}$ modelling whether appetizer, main course and dessert are included in the meal.
  With these, the four conditions form the following four clauses:
  $\clause_\text{(i)} = v_\text{m}$, $\clause_\text{(ii)} = \lnot v_\text{a} \lor \lnot v_\text{m} \lor \lnot v_\text{d}$, $\clause_\text{(iii)} = v_\text{d}$, and $\clause_\text{(iv)} = v_\text{a}$.
  Next, you can solve the formula $\clause_\text{(i)} \land \clause_\text{(ii)} \land \clause_\text{(iii)} \land \clause_\text{(iv)}$ with the help of a SAT solver, which will return \unsat{}.
  This tells you that there is no choice of the three courses that satisfies all conditions.
  As the host, you could now either put in more work for the meal (removing constraint~(i)) or decide to make the appetizer recipe some time else (removing constraint~(iv)).
  Assume you decide to remove constraint (iv), then the solution to $\clause_\text{(i)} \land \clause_\text{(ii)} \land \clause_\text{(iii)}$ found by the SAT solver is $\sol = \{ \lnot v_\text{a}, v_\text{m}, v_\text{d} \}$.
  Interpreting this solution, you know that making a main course and a dessert, but leaving out the appetizer, satisfies all constraints.
\end{example}

\section{Incremental SAT Solving under Assumptions\label{sec:inc-sat}}

% Incremental SAT solving
It is common that algorithms that solve problems with the help of SAT solvers produce a series of SAT problems that only differ slightly.
To be able to solve these sub-problems more efficiently, most modern SAT solvers provide an incremental interface that allows for retaining information learned in previous solver calls~\autocites{DBLP:journals/entcs/EenS03,handbook2-cdcl}.
CDCL solvers learn information in the form of clauses that are logical implications of the given clauses.
Retaining these learned clauses from previous calls allows the solver to determine satisfiability faster in subsequent calls.
In order for these learned clauses from previous queries to still hold for subsequent calls, it is only possible to \emph{add} clauses to the solvers internal formula, not remove them.
In addition, incremental SAT solvers support solving under assumptions.
The assumptions $\assumps$ are a set of literals that are treated as unit clauses, i.e., a solver call with internal formula $\formula$ and assumptions $\assumps$ either returns \sat{} and a solution $\sol \supset \assumps$, or \unsat{} and a subset $\core \subset \{\lnot l \mid l\in\assumps\}$ such that $\formula \land \bigwedge_{l \in \core} (\lnot l)$ is unsatisfiable.
The subset $\core$ is called an unsatisfiable \emph{core}~\autocite{handbook2-cdcl} and, intuitively, is an explanation for the unsatisfiability of the query.

\section{Maximum Satisfiability\label{sec:max-sat}}

% MaxSAT
Maximum satisfiability (MaxSAT) is the optimization variant of the SAT decision problem.
In it, the goal is to find a solution that satisfies as many of the given clauses as possible.
Most commonly and in this work, MaxSAT refers to the extension of \emph{weighted partial} MaxSAT, in which a set of \emph{hard} clauses $\formula$ and another set of \emph{soft} clauses $\softs$ are given.
Each clause $\clause \in \softs$ is assigned a weight $w_\clause$ and a solution $\sol$ that satisfies $\formula$ while achieving minimal weight of falsified soft clauses $\sum_{\clause\in\softs \mid \tau(\clause)=0} w_\clause$ is optimal for the problem.
Since the \NP-complete (recall \cref{sec:sat}) SAT decision problem can be reduced to MaxSAT, its optimization extension, MaxSAT is \NP-hard.
\TODO{(soundness?).}

% MaxSAT as a modelling language
In the same way that SAT can be used as a declarative language to solve other decision problems, MaxSAT can be used to solve optimization problems.

% Example: MaxSAT modelling
\begin{example}\label{ex:maxsat-modelling}
  Recall \cref{ex:sat-modelling} and assume the initial situation from that example situation.
  We can remove constraint (ii)---that three courses are too much effort---and change the task so that we want to minimize the number of courses.
  To formulate this task as a MaxSAT instance, we use clauses $\clause_\text{(i)}, \clause_\text{(iii)}, \clause_\text{(iv)}$ as the hard clauses of the instance.
  Encoding the objective (minimizing the number of courses in the meal) is done by defining $\{\lnot v_\text{a}, \lnot v_\text{m}, \lnot v_\text{d}\}$ as the set of soft clauses.
  Solving this MaxSAT instance with a MaxSAT solver will return the objective value 3 and solution $\sol=\{v_\text{a}, v_\text{m}, v_\text{d}\}$ encoding that the smallest (in terms of number of courses) meal still needs to contain all three courses.
\end{example}

% MaxSAT solving algorithms
Many algorithms for solving MaxSAT have been proposed over the recent years.
Best scalability to large instances is achieved by algorithms that solve MaxSAT by solving a number of SAT instances with the help of an underlying SAT solver, implicit hitting set approaches or solving MaxSAT via integer programming~\autocite{handbook2-maxsat}.
This thesis builds on the MaxSAT algorithms that solve a sequence of SAT problems;
these algorithms can be divided into two categories: solution-improving and core-guided~\autocite{DBLP:conf/sat/FuM06} algorithms.
The specific works that this thesis builds on are the solution-improving SAT-UNSAT search~\autocite{DBLP:journals/jsat/BerreP10}, the lower-bounding UNSAT-SAT search~\autocite{}, and the core-guided MSU3~\autocite{DBLP:journals/corr/abs-0712-1097} and OLL~\autocite{DBLP:conf/cp/MorgadoDM14} algorithms.

\TODO{Give intuition for each algorithm (attention: no totalizers yet!)}
OLL, as another core-guided procedure (originally proposed in the context of ASP~\autocite{DBLP:conf/iclp/AndresKMS12} and also successfully applied in MaxSAT~\autocites{DBLP:conf/cp/MorgadoDM14,DBLP:journals/jsat/IgnatievMM19}), handles the cardinality constraint over the active literals differently to MSU3.
Instead of a single cardinality constraint over all literals in $\Act$, a separate totalizer is built for every core returned after the unsatisfiable SAT solver calls.
The outputs of these many totalizers are then treated as additional soft clauses.

\section{Encoding Cardinality Constraints as Totalizers\label{sec:card-const}}

\TODO{Maybe move before MaxSAT so that cardinality constraints are known for MaxSAT algorithms}

% Cardinality constraints
As seen in \cref{sec:max-sat}, many MaxSAT algorithms make heavy use of cardinality constraints.
The same holds for the algorithmic approach presented in this thesis.
Informally speaking, cardinality constraints enforce a bound on how many literals in a set can be assigned to true.
Formally, for a set $L$ of literals and a bound $b \in \mathbb{N}$, $\texttt{As-CNF}\left(\sum_{l \in L} l \circ b\right)$ denotes a CNF formula that encodes the linear inequality $\sum_{l \in L} l \circ b$, where $\circ \in \{< ,> ,\geq, \leq, =\}$.
Numerous methods of forming such CNF formulas are known (e.g.,~\autocites{DBLP:conf/cp/BailleuxB03,DBLP:conf/cp/Sinz05,DBLP:journals/jsat/EenS06}).

% Totalizer encoding
In this work we make use of the totalizer encoding.
Given a set $L$ of $n$ input literals and a bound $k=1, \ldots, n$, the (incremental) totalizer~\autocites{DBLP:conf/cp/BailleuxB03,DBLP:conf/cp/MartinsJML14} encoding produces a CNF formula $\tot(L, k)$ that defines a set $\{\ov{L}{1}, \ldots, \ov{L}{k}\} \subset \var(\tot(L))$ of \emph{output literals} that---informally speaking---count the number of literals in $L$ assigned to true by solutions to $\tot(L)$:
if $\sol$ is an assignment that satisfies $\tot(L)$, then $\sol(\ov{L}{b}) = 1$ iff $\sum_{l \in L} \sol(l) < b$.
For applications where only either upper or lower bounding on the number of true literals is needed, the size of the encoded totalizer can be reduced by encoding implications in only one direction instead of in both (i.e., $\ov{L}{b} \leftarrow (\sum_{l \in L} l < b)$ or $\ov{L}{b} \rightarrow \sum_{l \in L} l < b$ but not both, depending on if upper or lower bounding is needed).
The algorithmic approach presented in this paper only uses upper bounding cardinality constraints, we therefore use the size-reduced version of the totalizer encoding.
The \emph{incremental} totalizer supports both increasing the bound $k$ and adding new input literals without having to rebuild the whole formula:
we have that $\tot(L, k) \subset \tot(L, k')$ and $\tot(L, k) \subset  \tot(L \cup L', k)$ hold for any bound $k' > k$ and set $L'$ of literals for which $L \cap L' =  \emptyset$. 
This is desirable when making incremental SAT calls where the bound or the set of input literals changes between calls, since it allows for making earlier calls to the SAT solver on a formula with fewer clauses and retaining information from these calls since extending the totalizer means adding clauses while reusing the ones that were previously added.
We use $\ove{L}{k}$ as a shorthand for the literal $\ov{L}{k+1}$;
furthermore, if the maximal bound $k$ of a totalizer $\tot(L,k)$ is clear from context or the bound is $k=|L|$, we omit it and simply write $\tot(L)$.
Note that the assignments of the auxiliary variables of the totalizer encoding are functionally defined by the assignment of the input and output variables.
As such we will leave them out from the solutions we describe in favour of brevity and clarity of examples. 