\chapter{Propositional Satisfiability\label{chap:satisfiability}}

% Signposting
In this chapter, an overview of propositional satisfiability (SAT) is provided.
We start by defining the SAT decision problem.
\Cref{sec:inc-sat} gives an overview of incremental SAT solving, a technique that the algorithmic approach proposed in this thesis makes heavy use of.
Next, we briefly discuss maximum satisfiability, the optimization variant of propositional satisfiability.
The chapter concludes with a section on encoding cardinality constraints in propositional logic.

\section{Propositional Satisfiability\label{sec:sat}}

% Propositional logic and SAT
For a Boolean variable $v$ there are two literals, the positive $v$ and the negative $\lnot v$. 
A clause $C$ is a set of (disjunction over) literals and a CNF formula $\formula$ is a set of (conjunction over) clauses.
The set of variables and literals appearing in $\formula$ are $\var(\formula)$ and $\lit(\formula)$, respectively.  
A truth assignment $\sol$ maps Boolean variables to 1 (true) or 0 (false).
The semantics of truth assignments are extended to a clause $C$ and a formula $\formula$ in the standard way: $\sol(C) = \max\{ \sol(l) \mid l \in C\}$ and $\sol(\formula) = \min\{\sol(C) \mid C \in \formula\}$.
When convenient, we view assignments $\sol$ over a set $\var(\formula)$ of variables as sets of literals $\sol = \{ v \mid v \in \var(\formula),  \sol(v) = 1\} \cup \{ \lnot v \mid v \in \var(\formula), \sol(v) = 0\}$.
An assignment $\sol$ for which $\sol(\formula) = 1$ is a solution to $\formula$.
The propositional satisfiability (SAT) problem asks whether a given formula $\formula$ has a solution.
A formula $\formula$ is satisfiable if it has solutions, otherwise it is unsatisfiable.

% Example: SAT
\begin{example}
  Consider the propositional formula $\formula_1 = a \land \lnot b$ over variables $\var(\formula_1) = \{a,b\}$.
  This formula is satisfiable since for $\sol=\{a,\lnot b\}$, $\sol(\formula_1)=1$.
  The formula $\formula_2 = a \land b \land (\lnot a \lor \lnot b)$ on the other hand is not satisfiable.
\end{example}

% SAT solvers
A SAT solver is an algorithm that determines the satisfiability of a given formula $\formula$.
If the formula is satisfiable, the solver returns ``satisfiable'' (\sat{}) and a solution $\sol$ with $\sol(\formula)=1$;
if $\formula$ is unsatisfiable, the return value is ``unsatisfiable'' (\unsat{}).

% CDCL solvers
So-called Conflict-Driven Clause Learning (CDCL) solvers are the state-of-the art in terms of SAT solving.
They have been found to defy the theoretical exponential worst-case performance on many SAT instances appearing for real-world problems.
Two central techniques in model CDCL solvers that enable this success are clause learning and search restarts~\autocite{handbook2-cdcl}.
SAT solving algorithms typically assign variables through either decisions or implications.
A decision assignment is the solver ``choosing'' an assignment for a given variable based on some heuristics.
On the other hand, an implication assignment is an assignment that is \emph{implied} from the assignments previously made, i.e., an assignment that logically follows, otherwise a clause would be falsified.
During the search procedure, the decision assignments made at earlier stages might lead to conflicts, meaning that the formula becomes unsatisfiable with these assignments.
In this case, the solver needs to backtrack and start over from an earlier point.
CDCL solvers add conflict analysis to this process, where the solver finds the set of decisions that lead to the conflict and forms a clause of them that can be added to the formula.
This clause contains information learned from the found conflict and retains it for coming iterations.
In addition to that, the search of a CDCL solver is restarted based on heuristics to improve their performance.

% SAT as a declarative modelling language
The SAT problem was proved to be \NP-complete by~\textcite{DBLP:conf/stoc/Cook71}.
This result is central to the modern day use of SAT as a declarative programming approach to solving other \NP-complete problems by encoding them as a propositional formula first, solving them with a SAT solver and then decoding the solution to the original problem context.
The advantage of using SAT as a declarative programming language for solving other problems comes from the fact that conflict-driven clause learning (CDCL) solvers for SAT are efficient in practice and can solve real-world instances with up to millions of variables and clauses~\autocite{handbook2-cdcl}.

% Example: SAT modelling
\begin{example}\label{ex:sat-modelling}
  We give an example of a real-world problem, modelling and solving it with the help of SAT.
  Assume the following situation:
  you have three guests coming over and want to cook a meal that contains something that each person likes.
  Guest A tells you they like tomato, courgette, and bell pepper;
  Guest B likes spinach, eggs, and peas;
  Guest C likes mushrooms and chilli.
  However, you only have enough money to get two ingredients from the store.
  This is actually an instantiation of the set covering decision problem~\autocite{DBLP:conf/coco/Karp72} that can be encoded into SAT.
  The groups of ingredients the guests like form three \emph{sets}, and you want to know if a \emph{cover} (another set of ingredients) of at most size two exists so that this cover intersects all three of the sets.
  The set covering problem can be encoded into SAT by introducing a variable for each element and encoding each set as a clause.
  For this example, this yields the following three clauses: $\clause_\text{A} = (v_\text{tomato} \lor v_\text{courgette} \lor v_\text{bell pepper})$, $\clause_\text{B} = (v_\text{spinache} \lor v_\text{egg} \lor v_\text{peas})$, $\clause_\text{C} = (v_\text{mushroom} \lor v_\text{chilli})$.
  The semantics of these variables are that iff an assignment $\sol$ assigns $\sol(v)=1$, then the element that this variable is included in the cover the assignment encodes.
  In addition to the sets, we need to encode the constraint that the cover can be at most of size two.
  For now, assume that $\texttt{As-CNF}\left(\sum_{v \in V)} v \le 2\right)$ (where $V$ is the set of all variables, i.e., $V = \var(\clause_\text{A}) \cup \var(\clause_\text{B}) \cup \var(\clause_\text{C})$) is a set of clauses that encodes exactly that.
  A set of clauses like this is known as a cardinality constraint and will be discussed in \cref{sec:card-const}.\\
  We can now build the formula $\clause_\text{A} \allowbreak \land \clause_\text{B} \allowbreak \land \clause_\text{C} \allowbreak \land \texttt{As-CNF}\left(\sum_{v \in V} v \le 2\right)$ and query a SAT solver for a solution to it.
  The solver will return \unsat{}, telling us that there is no solution to the given problem instance, i.e., that there is no two ingredients so that every guest likes at least one of them.
  Now if Guest C says that they also like peas, $\clause_\text{C}$ changes to $\clause_\text{C} = (v_\text{mushrooms} \lor v_\text{chilli} \lor v_\text{peas})$ and the formula becomes satisfiable.
  In this case, the SAT solver might return the solution $\sol$ with $\sol(v_\text{bell pepper}) = \sol(v_\text{peas}) = 1$ and $\sol(v) = 0$ for all other $v$.
  This tells us that in a dish containing bell pepper and peas, every guest will find something they like.
\end{example}

\section{Incremental SAT Solving under Assumptions\label{sec:inc-sat}}

% Incremental SAT solving
It is common that algorithms that solve problems with the help of SAT solvers produce a series of SAT problems that only differ slightly.
To be able to solve these sub-problems more efficiently, most modern SAT solvers provide an incremental interface that allows for retaining information in form of clauses learned in previous solver calls~\autocites{DBLP:journals/entcs/EenS03,handbook2-cdcl}.
Retaining these learned clauses from previous calls allows CDCL solvers to determine satisfiability faster in subsequent calls.
In order for these learned clauses from previous queries to still hold for subsequent calls, it is only possible to \emph{add} clauses to the solvers internal formula, not remove them.
Additionally, incremental SAT solvers support solving under assumptions.
The assumptions $\assumps$ are a set of literals that are treated as unit clauses, i.e., a solver call with internal formula $\formula$ and assumptions $\assumps$ either returns \sat{} and a solution $\sol \supset \assumps$, or \unsat{} and a subset $\core \subset \{\lnot l \mid l\in\assumps\}$ such that $\formula \land \bigwedge_{l \in \core} (\lnot l)$ is unsatisfiable.
The subset $\core$ is called an unsatisfiable \emph{core}~\autocite{handbook2-cdcl} and, intuitively, is an explanation for the unsatisfiability of the query.

\section{Encoding Cardinality Constraints as Totalizers\label{sec:card-const}}

% Cardinality constraints
As we will see in \cref{sec:max-sat}, many MaxSAT algorithms make heavy use of cardinality constraints.
The same holds for the algorithmic approach presented in this thesis.
Informally speaking, cardinality constraints enforce a bound on how many literals in a set can be assigned to true.
Formally, for a set $L$ of literals and a bound $b \in \mathbb{N}$, $\texttt{As-CNF}\left(\sum_{l \in L} l \circ b\right)$ denotes a CNF formula that encodes the linear inequality $\sum_{l \in L} l \circ b$, where $\circ \in \{< ,> ,\geq, \leq, =\}$.
Numerous methods of forming such CNF formulas are known (e.g.,~\autocites{DBLP:conf/cp/BailleuxB03,DBLP:conf/cp/Sinz05,DBLP:journals/jsat/EenS06}).

% Totalizer encoding
In this work we make use of the totalizer encoding.
Given a set $L$ of $n$ input literals and a bound $k=1, \ldots, n$, the (incremental) totalizer~\autocites{DBLP:conf/cp/BailleuxB03,DBLP:conf/cp/MartinsJML14} encoding produces a CNF formula $\tot(L, k)$ that defines a set $\{\ov{L}{1}, \ldots, \ov{L}{k}\} \subset \var(\tot(L))$ of \emph{output literals} that---informally speaking---count the number of literals in $L$ assigned to true by solutions to $\tot(L)$:
if $\sol$ is an assignment that satisfies $\tot(L)$, then $\sol(\ov{L}{b}) = 1$ iff $\sum_{l \in L} \sol(l) < b$.
For applications where only either upper or lower bounding on the number of true literals is needed, the size of the encoded totalizer can be reduced by encoding implications in only one direction instead of in both (i.e., $\ov{L}{b} \leftarrow (\sum_{l \in L} l < b)$ or $\ov{L}{b} \rightarrow \sum_{l \in L} l < b$ but not both, depending on if upper or lower bounding is needed).
The algorithmic approach presented in this paper only uses upper bounding cardinality constraints, we therefore use the size-reduced version of the totalizer encoding.
The \emph{incremental} totalizer supports both increasing the bound $k$ and adding new input literals without having to rebuild the whole formula:
we have that $\tot(L, k) \subset \tot(L, k')$ and $\tot(L, k) \subset  \tot(L \cup L', k)$ hold for any bound $k' > k$ and set $L'$ of literals for which $L \cap L' =  \emptyset$. 
This is desirable when making incremental SAT calls where the bound or the set of input literals changes between calls, since it allows for making earlier calls to the SAT solver on a formula with fewer clauses and retaining information from these calls since extending the totalizer means adding clauses while reusing the ones that were previously added.
We use $\ove{L}{k}$ as a shorthand for the literal $\ov{L}{k+1}$;
furthermore, if the maximal bound $k$ of a totalizer $\tot(L,k)$ is clear from context or the bound is $k=|L|$, we omit it and simply write $\tot(L)$.
Note that the assignments of the auxiliary variables of the totalizer encoding are functionally defined by the assignment of the input and output variables.
As such we will leave them out from the solutions we describe in favour of brevity and clarity of examples. 

\section{Maximum Satisfiability\label{sec:max-sat}}

% MaxSAT
Maximum satisfiability (MaxSAT) is the optimization variant of the SAT decision problem.
In it, the goal is to find a solution that satisfies as many of the given clauses as possible.
Most commonly and in this work, MaxSAT refers to the extension of \emph{weighted partial} MaxSAT, in which a set of \emph{hard} clauses $\formula$ and another set of \emph{soft} clauses $\softs$ are given.
Each clause $\clause \in \softs$ is assigned a weight $w_\clause$ and a solution $\sol$ that satisfies $\formula$ while achieving minimal weight of falsified soft clauses $\sum_{\clause\in\softs \mid \tau(\clause)=0} w_\clause$ is optimal for the problem.
Since the \NP-complete (recall \cref{sec:sat}) SAT decision problem can be reduced to MaxSAT, its optimization extension, MaxSAT is \NP-hard.
\TODO{(soundness?).}

% MaxSAT as a modelling language
In the same way that SAT can be used as a declarative language to solve other decision problems, MaxSAT can be used to solve optimization problems.

% Example: MaxSAT modelling
\begin{example}\label{ex:maxsat-modelling}
  Recall \cref{ex:sat-modelling}.
  We can change the problem from the set covering decision problem to the optimization variant by asking for find the \emph{smallest} cover rather than giving an upper bound on the size of the cover.
  This is done by removing the cardinality constraint from the encoding and using the encoded sets as hard clauses for a partial MaxSAT instances.
  In addition to that, for every variable $v\in V$, a soft clause $\lnot v$ is added.
  Solving this MaxSAT instance for the initial situation, the MaxSAT solver will return that at least three of the soft clauses need to be falsified, i.e., that at least three ingredients must be chosen so that every guest likes something.
  An optimal solution $\sol$ that the solver might return for this has $\sol(v_\text{tomato}) = \sol(v_\text{spinach}) = \sol(v_\text{mushroom}) = 1$ and $\sol(v) = 0$ for all other $v$.
  After we modify the instance to account for guest C not liking peas, the MaxSAT solver might give us the optimal solution $\sol$ with $\sol(v_\text{bell pepper}) = \sol(v_\text{peas}) = 1$ and $\sol(v) = 0$ for all other $v$.
  There is no valid cover with size smaller than two.
\end{example}

% MaxSAT solving algorithms
Many algorithms for solving MaxSAT have been proposed over the recent years.
Best scalability to large instances is achieved by algorithms that solve MaxSAT by solving a number of SAT instances with the help of an underlying SAT solver, implicit hitting set approaches, or solving MaxSAT via integer programming~\autocite{handbook2-maxsat}.
This thesis builds on the MaxSAT algorithms that solve a sequence of SAT problems;
these algorithms can be categorized as either solution-improving, bound-improving or core-guided algorithms.
Detailed descriptions for most of these algorithms can be found in~\autocite{handbook2-maxsat}.

% SAT-UNSAT and UNSAT-SAT
The two simplest algorithms we build on are solution-improving SAT-UNSAT search~\autocite{DBLP:journals/jsat/BerreP10} and bound-improving UNSAT-SAT search~\autocite{DBLP:conf/sat/FuM06}.
SAT-UNSAT (also known as Linear SAT-UNSAT (LSU)) search solves MaxSAT by starting from a known satisfiable model for the hard clauses.
From this, a cardinality constraint is added to the SAT solver, enforcing that the next found model achieves a better objective value than the last.
If such a model is found, the cardinality constraint is tightened to the objective value of this new model.
As soon as the SAT solver return \unsat{} for a call, the last found model is known to be optimal.
Because this search procedure goes through a series of satisfiable calls first, terminating at the first unsatisfiable call, it is known as SAT-UNSAT search.
UNSAT-SAT search is similar, however the optimal value is found by lower-bounding instead of upper-bounding.
It starts by adding a tight cardinality constraint to the SAT solver, getting unsatisfiable calls and slowly loosening the constraint until a first satisfiable query is reached.
The idea of UNSAT-SAT search was first proposed not as an algorithm, but as a formulation for subset satisfiable boolean formulas~\autocite{DBLP:journals/tcad/XuRS03}.
Later it was lifted to be used as a MaxSAT algorithm~\autocite{DBLP:conf/sat/FuM06}.

% MSU3 and OLL
The other two algorithms we are building on in this thesis are MSU3~\autocite{DBLP:journals/corr/abs-0712-1097} and OLL~\autocite{DBLP:conf/cp/MorgadoDM14,DBLP:journals/jsat/IgnatievMM19}.
Both of these search procedures are core-guided, meaning they make use of unsatisfiable cores returned by the SAT solver to more efficiently steer the search.
Core-guided MaxSAT was first proposed by the algorithm now known as Fu-Malik~\autocite{DBLP:conf/sat/FuM06}.
The central insight behind core-guided MaxSAT is that an optimal solution must falsify at least one of the soft clauses in every core.
In the MSU3 algorithm, a new relaxation variable is added to each soft clause.
These relaxation variables are assumed to false and cores are extracted over them.
When a relaxation variable for a soft clause appears in a core, this relaxation variable is removed from the assumptions and the added to a cardinality constraint allowing some relaxation variables to be true.
The bound on the cardinality constraint is increased by one every iteration.
With this, MSU3 as also every other core-guided algorithm, makes a series of unsatisfiable SAT queries, terminating at the first satisfiable one, which yields the optimal solution.
OLL, which was first proposed for the paradigm of answer set programming~\autocite{DBLP:conf/iclp/AndresKMS12} and later applied to MaxSAT~\autocite{DBLP:conf/cp/MorgadoDM14,DBLP:journals/jsat/IgnatievMM19}, differs from MSU3 in how the extracted cores are relaxed.
Instead of building one large cardinality constraint over all cores, it builds an individual cardinality constraint for each core.
Furthermore, these cardinality constraints are not treated as hard but as additional \emph{soft} clauses, meaning they can be relaxed in future iterations of the algorithm.

% MaxSAT algorithms and cardinality constraints
All MaxSAT algorithms that solve a series of SAT queries need to build cardinality constraints over the soft clauses of the MaxSAT instance and typically these only change slightly from query to query.
For this reason, incremental cardinality constraints such as the incremental totalizer encoding are employed in modern MaxSAT solvers to allow for incrementally using the underlying SAT solver without resetting it.