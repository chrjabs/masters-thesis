\chapter{Propositional Satisfiability\label{chap:satisfiability}}

% Signposting
In this chapter, an overview of propositional satisfiability (SAT) is provided.
We start by defining the SAT decision problem.
\Cref{sec:inc-sat} gives an overview of incremental SAT solving, a technique that the algorithmic approch proposed in this thesis makes heavy use of.
Next, we briefly discuss maximum satisfiability, the optimization variant of propositional satisfiability.
The chapter concludes with a section on encoding cardinality constraints in propositional logic.

\section{Propositional Satisfiability\label{sec:sat}}

% Propositional logic and SAT
For a Boolean variable $v$ there are two literals, the positive $v$ and the negative $\lnot v$. 
A clause $C$ is a set of (disjunction over) literals and a CNF formula $\formula$ is a set of (conjunction over) clauses.
The set of variables and literals appearing in $\formula$ are $\var(\formula)$ and $\lit(\formula)$, respectively.  
A truth assignment $\sol$ maps boolean variables to 1 (true) or 0 (false).
The semantics of truth assignments are extended to a clause $C$ and a formula $\formula$ in the standard way: $\sol(C) = \max\{ \sol(l) \mid l \in C\}$ and $\sol(\formula) = \min\{\sol(C) \mid C \in \formula\}$.
When convenient, we view assignments $\sol$ over a set $\var(\formula)$ of variables as sets of literals $\sol = \{ v \mid v \in \var(\formula),  \sol(v) = 1\} \cup \{ \lnot v \mid v \in \var(\formula), \sol(v) = 0\}$.
An assignment $\sol$ for which $\sol(\formula) = 1$ is a solution to $\formula$.
The propositional satisfiability (SAT) problem asks whether a given formula $\formula$ has a solution.
A formula $\formula$ is satisfiable if it has solutions, otherwise it is unsatisfiable.

% Example: SAT
\begin{example}
  Consider the propositional formula $\formula_1 = a \land \lnot b$ over variables $\var(\formula_1) = \{a,b\}$.
  This formula is satisfiable since for $\sol=\{a,\lnot b\}$, $\sol(\formula_1)=1$.
  The formula $\formula_2 = a \land b \land (\lnot a \lor \lnot b)$ on the other hand is not satisfiable.
\end{example}

% SAT solvers
A SAT solver is an algorithm that determines the satisfiability of a given formula $\formula$.
If the formula is satisfiable, the solver returns ``satisfiable'' (SAT) and a solution $\sol$ with $\sol(\formula)=1$;
if $\formula$ is unsatisfiable, the return value is ``unsatisfiable'' (UNSAT).

% SAT as a declarative modelling language
\TODO{Extend and explain solving pipeline properly. Maybe move to Intro.}
The SAT problem was proved to be $\mathcal{NP}$-complete by~\textcite{DBLP:conf/stoc/Cook71}.
This result is central to the modern day use of SAT as a declarative programming approach to solving other $\mathcal{NP}$-complete problems by encoding them as a propositional formula first, solving them with a SAT solver and then decoding the solution to the original problem context.
The advantage of using SAT as a declarative programming language for solving other problems comes from the fact that---even though SAT is $\mathcal{NP}$-complete, and it is unclear if a polynomial time algorithm for solving it exists---conflict-driven clause learning solvers~\autocite{handbook2-cdcl} for SAT are efficient in practice and can solve instances with millions of variables and clauses~\autocite{}.

% Example: SAT modelling
\begin{example}\label{ex:sat-modelling}
  We give an example of a real-world problem, modelling and solving it with the help of SAT.
  Assume you have the following situation:
  you want to plan a meal for a guest coming over, and you do not know whether to include an appetizer, a main course and a dessert.
  However, you know the following constraints:
  (i)~there must be a main course in every meal, (ii)~having three courses is too much effort, (iii)~your guest would like to have dessert, and (iv)~you have a new appetizer recipe that you would like to try making.
  To model this problem as SAT, you can introduce three variables $v_\text{a}$, $v_\text{m}$, $v_\text{d}$ modelling whether appetizer, main course and dessert are included in the meal.
  With these, the four conditions form the following four clauses:
  $\clause_\text{(i)} = v_\text{m}$, $\clause_\text{(ii)} = \lnot v_\text{a} \lor \lnot v_\text{m} \lor \lnot v_\text{d}$, $\clause_\text{(iii)} = v_\text{d}$, and $\clause_\text{(iv)} = v_\text{a}$.
  Next, you can solve the formula $\clause_\text{(i)} \land \clause_\text{(ii)} \land \clause_\text{(iii)} \land \clause_\text{(iv)}$ with the help of a SAT solver, which will return UNSAT.
  This tells you that there is no choice of the three courses that satisfies all conditions.
  As the host, you could now either put in more work for the meal (removing constraint~(i)) or decide to make the appetizer recipe some time else (removing constraint~(iv)).
  Assume you decide to remove constraint (iv), then the solution to $\clause_\text{(i)} \land \clause_\text{(ii)} \land \clause_\text{(iii)}$ found by the SAT solver is $\sol = \{ \lnot v_\text{a}, v_\text{m}, v_\text{d} \}$.
  Interpreting this solution, you know that making a main course and a dessert, but leaving out the appetizer, satisfies all constraints.
\end{example}

\section{Incremental SAT Solving under Assumptions\label{sec:inc-sat}}

% Incremental SAT solving
It is common that algorithms that solve problems with the help of SAT solvers produce a series of SAT problems that only differ slightly.
To be able to solve these sub-problems more efficiently, most modern SAT solvers provide an incremental interface that allows for retaining information learned in previous solver calls~\autocite{DBLP:journals/entcs/EenS03,handbook2-cdcl}\TODO{ check if new CDCL chapter can be referenced}.
In order for the learned information \TODO{define learned info} from previous solver queries to still hold for subsequent calls, it is only possible to \emph{add} clauses to the solvers internal formula, not remove them.
In addition, incremental SAT solvers support solving under assumptions.
The assumptions $\assump$ are a set of literals that are treated as unit clauses, i.e., a solver call with internal formula $\formula$ and assumptions $\assump$ either returns SAT and a solution $\sol \supset \assump$, or UNSAT and a subset $\core \subset \{\lnot l \mid l\in\assump\}$ such that $\formula \land \bigwedge_{l \in \core} (\lnot l)$ is unsatisfiable.
The subset $\core$ is called an unsatisfiable \emph{core}~\autocite{} and, intuitively, is an explanation for the unsatisfiability of the query.

\TODO{Define \satsolver{}.
Returns $\res,\sol,\core$ where $\sol$ is only returned if $\res=\text{SAT}$ and $\core$ is only returned if $\res=\text{UNSAT}$.
When we don't need some of the returned stuff, we omit it.}

\section{Maximum Satisfiability\label{sec:max-sat}}

% MaxSAT
Maximum satisfiability (MaxSAT) is the optimization variant of the SAT decision problem.
In it, the goal is to find a solution that satisfies as many of the given clauses as possible.
Most commonly and in this work, MaxSAT refers to the extension of \emph{weighted partial} MaxSAT, in which a set of \emph{hard} clauses $\formula$ and another set of \emph{soft} clauses $\softs$ are given.
Each clause $\clause \in \softs$ is assigned a weight $w_\clause$ and a solution $\sol$ that satisfies $\formula$ while achieving minimal weight of falsified soft clauses $\sum_{\clause\in\softs \mid \tau(\clause)=0} w_\clause$ is optimal for the problem.
\TODO{Mention hardness (and soundness?).}

% MaxSAT as a modelling language
In the same way that SAT can be used as a declarative language to solve other decision problems, MaxSAT can be used to solve optimization problems.

% Example: MaxSAT modelling
\begin{example}\label{ex:maxsat-modelling}
  \TODO{Adapt \cref{ex:sat-modelling}, removing constraint (ii), changing it too the objective}
\end{example}

\section{Encoding Cardinality Constraints as Totalizers\label{sec:card-const}}

\TODO{Mention why this is discussed here.}

% Cardinality constraints
A common type of constraint to appear when encoding problems into SAT is that of a cardinality constraint.
Informally speaking, cardinality constraints enforce a bound on how many literals in a set can be assigned to true.
Formally, for a set $L$ of literals and a bound $b \in \mathbb{N}$, $\texttt{As-CNF}\left(\sum_{l \in L} l \circ b\right)$ denotes a CNF formula that encodes the linear inequality $\sum_{l \in L} l \circ b$, where $\circ \in \{< ,> ,\geq, \leq, =\}$.
Numerous methods of forming such CNF formulas are known~\autocite{DBLP:conf/cp/BailleuxB03}\TODO{better reference}.

% Totalizer encoding
In this work we make use of the totalizer encoding.
Given a set $L$ of $n$ input literals and a bound $k=1, \ldots, n$, the (incremental) totalizer~\autocite{DBLP:conf/cp/BailleuxB03,DBLP:conf/cp/MartinsJML14} encoding produces a CNF formula $\tot(L, k)$ that defines a set $\{\ov{L}{1}, \ldots, \ov{L}{k}\} \subset \var(\tot(L))$ of \emph{output literals} that---informally speaking---count the number of literals in $L$ assigned to true by solutions to $\tot(L)$:
if $\tau$ is an assignment that satisfies $\tot(L)$, then $\tau(\ov{L}{b}) = 1$ if $\sum_{l \in L} \tau(l) < b$.
Even though the full totalizer encoding also supports lower bounding the number of literals (in which case we would have $\tau(\ov{L}{b})=1$ \emph{if and only if} $\sum_{l \in L} \tau(l) < b$), since in this work we only use upper bounds, the size of the encoded totalizer can be reduced by leaving the corresponding clauses out.
\TODO{Rewrite previous sentence(s). Possibly first define full totalizers and then discuss reduced variant.}
The incremental totalizer supports both increasing the bound $k$ and adding new input literals without having to rebuild the whole formula:
we have that $\tot(L, k) \subset \tot(L, k')$ and $\tot(L, k) \subset  \tot(L \cup L', k)$ hold for any bound $k' > k$ and set $L'$ of literals for which $L \cap L' =  \emptyset$. 
\TODO{Discuss why this is desirable.}
We use $\ove{L}{k}$ as a shorthand for the literal $\ov{L}{k+1}$.
Note that the assignments of the auxiliary variables of the totalizer encoding are functionally defined by the assignment of the input and output variables.
As such we will leave them out from the solutions we describe in favour of brevity and clarity of examples. 